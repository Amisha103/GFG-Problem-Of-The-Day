Form the Largest Number

Given an array of integers arr[] representing non-negative integers, arrange them so that after concatenating all of them in order, it results in the largest possible number. Since the result may be very large, return it as a string.

Examples:

Input: arr[] = [3, 30, 34, 5, 9]
Output: 9534330
Explanation: Given numbers are [3, 30, 34, 5, 9], the arrangement [9, 5, 34, 3, 30] gives the largest value.
Input: arr[] = [54, 546, 548, 60]
Output: 6054854654
Explanation: Given numbers are [54, 546, 548, 60], the arrangement [60, 548, 546, 54] gives the largest value.
Input: arr[] = [3, 4, 6, 5, 9]
Output: 96543
Explanation: Given numbers are [3, 4, 6, 5, 9], the arrangement [9, 6, 5, 4, 3] gives the largest value.
Constraints:
1 ≤ arr.size() ≤ 105
0 ≤ arr[i] ≤ 105

Expected Complexities
Time Complexity: O(n log n)
Auxiliary Space: O(n)

JAVA-
class Solution {
    public String findLargest(int[] arr) {
     
        int n = arr.length;
        
    
        String[] str = new String[n];
        for(int i = 0; i < n; i++){
            str[i] = ""+arr[i];
        }
        
        
        Arrays.sort(str, (a, b) -> (b + a).compareTo(a + b));
        
    
        if(str[0].equals("0")) {
            return "0";
        }
        

        StringBuilder sb = new StringBuilder();
        for(String s : str){
            sb.append(s);
        }
        
        return sb.toString();
    }
}


PYTHON-
class Solution:

	def findLargest(self, arr):
	    arr = list(map(str, arr))
        
        
        def compare(a, b):
            if a + b > b + a:
                return -1 
            elif a + b < b + a:
                return 1
            else:
                return 0
        
        
        arr.sort(key=cmp_to_key(compare))
        
        
        if arr[0] == "0":
            return "0"
        
        
        return ''.join(arr)
	
	    
