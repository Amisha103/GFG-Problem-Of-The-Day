Count Subset With Target Sum II

Given an array arr[] and an integer k, find the count of subsets whose sum is equals to k.

Note: It is guaranteed that the no of valid subsets will fit within a 32-bit integer.

Examples:

Input: arr[] = [1, 3, 2], k = 3
Output: 2
Explanation: The two subsets whose sum is equals to k are [1, 2] and [3].
Input: arr[] = [4, 2, 3, 1, 2], k = 4
Output: 3
Explanation: The three subsets whose sum is equals to k are [4], [2, 2] and [3, 1].
Input: arr[] = [10, 20, 30], k = 25
Output: 0
Explanation: No subsets exits with sum equals to k.
Constraints:
1 ≤ arr.size() ≤ 40
-107 ≤ arr[i], k ≤ 107

JAVA-
class Solution {
    public int countSubset(int[] arr, int k) {
        int n = arr.length;
        int mid = n / 2;
        int left[] = Arrays.copyOfRange(arr, 0, mid);
        int right[] =   Arrays.copyOfRange(arr, mid, n);
        HashMap<Integer, Integer> map = new HashMap<>();
        generateSum(0, 0, left, map);
        return countSubset(0, 0, k, right, map);
    }
void generateSum(int ind, int sum, int[] arr, HashMap<Integer, Integer> map)
{
    if(ind == arr.length)
    {
        map.put(sum, map.getOrDefault(sum, 0) + 1);
        return;
    }
    
    generateSum(ind + 1, sum + arr[ind], arr, map);
    generateSum(ind + 1, sum, arr, map);
    
}

int countSubset(int ind, int sum,int k, int[]arr, HashMap<Integer, Integer> map)
{
    if(ind == arr.length)
    {
        return map.getOrDefault(k - sum, 0);
    }
    int take = countSubset(ind + 1, sum + arr[ind], k, arr, map);
    int notTake = countSubset(ind + 1, sum, k, arr, map);
    return take + notTake;
}
  
}


PYTHON-
class Solution:
    def countSubset(self, arr, k):
        n = len(arr)
        mid = n // 2

        left = arr[:mid]
        right = arr[mid:]
        
        mp = {}
        self.generateSum(0, 0, left, mp)

        return self.countSum(0, 0, k, right, mp)

    def generateSum(self, ind, sm, left, mp):
        if ind == len(left):
            mp[sm] = mp.get(sm, 0) + 1
            return

        self.generateSum(ind + 1, sm + left[ind], left, mp)
        self.generateSum(ind + 1, sm, left, mp)

    def countSum(self, ind, sm, k, right, mp):
        if ind == len(right):
            return mp.get(k - sm, 0)

        take = self.countSum(ind + 1, sm + right[ind], k, right, mp)
        notTake = self.countSum(ind + 1, sm, k, right, mp)

        return take + notTake
